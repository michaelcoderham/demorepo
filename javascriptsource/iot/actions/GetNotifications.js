// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
import { Big } from "big.js";

// BEGIN EXTRA CODE
// END EXTRA CODE

/**
 * @param {string} serviceUUID
 * @param {MxObject} characteristic
 * @param {MxObject} measurement
 * @returns {Promise.<boolean>}
 */
export async function GetNotifications(serviceUUID, characteristic, measurement) {
	// BEGIN USER CODE
	const gattServer = window.gattServer;
	const characteristics = window.characteristics;

	if(gattServer && gattServer.connected) {
		return new Promise((resolve, reject) => {
			gattServer.getPrimaryService(serviceUUID)
			.then( (primaryService) => {
				return primaryService.getCharacteristic( characteristic.get('UUID') );
			}).then( (characteristicObj) => {
				const guid = measurement.getGuid();
				if (guid in characteristics) {
					resolve(true);
					return;
				}
				if (!characteristicObj.properties.notify) {
					reject('Characteristic ' + characteristic.get('UUID') + ' can not emit notifications');
					return;
				}
				characteristicObj.startNotifications()
				.then(() => {
					characteristicObj.addEventListener(
						'characteristicvaluechanged',
						(event) => {
							const dataView = event.target.value;
							let byteIndex = 0;
							for (let i = 1; i <= 9; i++) {
								let typeValue = characteristic.get('TypeValue0' + i);
								if (typeValue !== undefined && typeValue !== '') {
									let parsedValue = dataView['get' + typeValue](byteIndex, true);
									measurement.set('Value0' + i, parsedValue);
									byteIndex += parseInt(typeValue.match(/\d+/))/8;
								}
							}
							if (characteristic.get('StringValue')) {
								measurement.set('ValueString', String.fromCharCode.apply(null, new Uint8Array(dataView.buffer, byteIndex)));
							}
							mx.data.commit({
								mxobj: measurement,
								callback: function() {
								},
								error: function(e) {
									alert('Could not commit object: ' + e);
								}
							});
						}
					);
					resolve(true);
				}).catch(error => console.error(error.code, error.name, error.message));
			});
		});
	} else{
		return Promise.reject('Not connected to gatt server');
	}
	// END USER CODE
}
